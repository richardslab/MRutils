---
title: "Vitamin D - COVID-19 MR (redo)"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set("root.dir", "~/RichardsLab/VitaminD_COVID_MR_reproduce/")
knitr::opts_chunk$set(cache=TRUE)

require(tidyr)
require(plyr)
require(dplyr)
require(readxl)
require(glue)

source("utils.R")

required_headers <- c("rsid", "CHR", "POS", "MAF", "P", "beta", "EA", "NEA", "EAF", "SE")

outcome_gwas <- "COVID-A2"
exposure_name <- "Vitamin D"


```


## Extract data from VitaminD GWAS
Since the input data is given to us as an excel spreadsheet, we have to extract the information from it
"manually". In order to avoid copy-paste errors, we extract the information using the readxl library. 

```{r extract excelsheet data}

data = read_excel("../raw_data/1-s2.0-S0002929720300173-mmc2.xlsx", 
                  sheet = "Table S2", 
                  skip = 4, 
                  .name_repair = "minimal") %>% subset(select = c(1:5, 13:17))
first_blank = min(which(is.na(data$RSID)))
# use the first blank line as an indication of the end of the data, since the dictionary comes after
if (length(first_blank) == 1) {
  data = data[1:first_blank - 1,]
}
names(data)[8] = "beta"
names(data)[1] = "rsid"
data = data %>% mutate_at(.vars = c("EAF", "MAF", "beta", "SE", "P"), as.numeric)
data = data %>% mutate(POS = BP, CHR = gsub("^chr", "", CHR))


data <- subset(data, select = required_headers)

write.table(data, "../derived_data/extracted_VD_SNPs.tsv", 
            sep = "\t", 
            row.names = FALSE, 
            quote = FALSE)

significant_VD_snps = data %>% subset(P < 5e-8 & MAF >= 0.01) 
write.table(significant_VD_snps, 
            "../derived_data/significant_VD_SNPs.tsv", 
            sep = "\t", 
            row.names = F, 
            quote = F)
```
### Outcome A2 

## extract relevant SNPs
```{r extract A2 Snps}

map_outcome_data <- function(x) {
  
  mutate(x, 
         beta = all_inv_var_meta_beta, 
         P = all_inv_var_meta_p, 
         EA = ALT, 
         NEA = REF, 
         MAF = all_meta_AF, 
         EAF = all_meta_AF, 
         SE = all_inv_var_meta_sebeta) %>% 
    subset(select=required_headers)
  
}

  A2 <- "../raw_data/COVID19_HGI_A2_ALL_leave_23andme_20201020.b37.txt.gz"
  A2_outcome <- extract_snps_from_bgzip(outcome = A2, snps = significant_VD_snps) %>% map_outcome_data()
  
```

## find names for un-named snps
```{r find_unnamed_snps, cache=TRUE}
## this can take time and hits the API multiple times....

withIds <- get_unknown_rsids_from_locus(A2_outcome)

write.table(withIds, "../derived_data/rsIdsFromdbSnp.txt", quote = F, sep = '\t', row.names = F)
```

```{r post-cache read variable}
withIds <- read.table("../derived_data/rsIdsFromdbSnp.txt", sep = '\t', header = T)

```

## merge into other data
```{r merge found snps into data}
A2_outcome_with_rsids <- merge_rsids_into_gwas(A2_outcome, withIds)
  
print(glue("there are {nrow(A2_outcome_with_rsids%>%subset(is.na(rsid)))} variants lacking rsid"))

merged_A2_and_VD <- merge(significant_VD_snps, suffixes = c(".exp", ".out"),
                          A2_outcome_with_rsids, 
                          by = c("rsid", "CHR", "POS"), 
                          all.x = T,
                          )
```

```{r get proxies, cache=TRUE}
## these should be inputs
token <- "151d285edb97" ## should be in a environment variable and input using 
pop <- c("CEU", "TSI", "GBR", "IBS")

##takes time (hits the LDLink API)
proxies <- get_proxies(subset(merged_A2_and_VD, is.na(MAF.out))$rsid, token, population = pop, results_dir = "../derived_data/", skip_api = TRUE )
```

```{r use proxies}

proxies_in_outcome <- extract_snps_from_bgzip(A2, snps = proxies) %>% map_outcome_data()

# merge exposure proxies with exposure
exposure_and_proxies <- merge(proxies, significant_VD_snps, by.x = c("query_rsid","CHR"), by.y = c("rsid","CHR"), suffixes = c(".proxy",".exp"))

allele_matrix = strsplit(input, ",", fixed = T)[[1]] %>% 
  {llply(strsplit(x = ., split = "=", fixed = T))} %>% 
  purrr::transpose() %>% 
  do.call(what = rbind)

replace=allele_matrix[1,]
pattern=allele_matrix[2,]


# remove chimeric snps and then the smallest P
chimeric <- c("(A/T)", "(T/A)", "(C/G)", "(G/C)")
proxies_in_covid <- data_proxies %>%
  subset(Alleles %notin% chimeric) %>%
  group_by(query_rsid) %>%
  slice_min(order_by = "P", n = 1)


# merge with the exposure
merged_with_proxies <- merge(significant_VD_snps,
                             proxies_in_covid,
                             suffixes = c(".exp",".out"),
                             by.x = c("rsid", "CHR"),
                             by.y = c("query_rsid", "CHR")) %>%
  select(-MAF) %>%
  select(c( -"R2", -"Correlated_Alleles", -"Alleles", -"Locus", -"POS.out"))

# merged_with_proxies %<>% mutate(proxy_rsid = rsid.out, rsid.out = NULL,
#                                 POS = POS.exp, POS.exp = NULL)

```

Now we need to make sure that we do not have SNPs in high LD next to each other

```{r prune_snps, cache=TRUE}
pruned_combined_snps <- prune_snps(merged_and_combined, population = pop, token = token)

print(glue("Total number of SNPs for use in 2-Sample MR: {nrow(pruned_combined_snps)}."))

write.table(pruned_combined_snps, file = "../derived_data/SNPsFor2SMR.txt", sep = '\t', quote = F, row.names = F)
```

```{r get MR results}
results <- get_2smr_results("../derived_data/SNPsFor2SMR.txt")
```

```{r show results}
show(results$regressed)
show(results$single_snp)
show(results$density_plot)
show(results$scatter_plot)

```




